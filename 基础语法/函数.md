### 函数
一个典型的函数定义由如下部分组成:  
* 返回类型(return type)
* 函数名(function name)
* 参数列表(args)
* 函数体  

### 局部变量  
众所周知,函数体是个语句块;块构成一个作用域,可以在其中定义变量.形参和函数体内部定义的变量统称为局部变量(local variable),它们对于函数而言是局部的,仅在函数作用域内可见,同时局部变量会隐藏在外层作用域中同名的其他变量声明.  

#### 自动对象
对于普通局部变量对应的对象来说,当函数的控制路径经过变量定义语句时创建该对象,当到达定义所在块的结尾时销毁它.我们把只存在块执行期间的对象称为自动对象(automatic object).函数的形参和内部定义的普通变量都是自动对象.  

#### 局部静态对象  
* 某些情况下,有必要使局部变量的生命周期贯穿函数调用及之后,可将局部变量定义成 static 类从而获得这样的对象.  
* 局部静态变量(local static object)在程序执行至其定义语句时进行初始化,并直至程序运行结束才被销毁,此期间中即使运行其的函数结束执行也不会被对其产生影响.  
* 局部静态变量只在第一次赋初值是进行赋值操作.  

### 参数传递
#### 值传递
函数的形参若是非引用类型则是值传递,将传入参数的值拷贝传入函数,函数内部修改形参不会影响实参.

#### 指针传递
同非引用传递一样,将传入指针的值拷贝传入函数,但可间接通过指针的解引用修改其所指向的对象的值.  

#### 引用传递
形参为引用类型时,可通过函数内部修改外部实参,也可减少传递参数时的拷贝开销(常用于大型类类型对象或容器对象和不支持拷贝操作的类如: IO).  
一个函数只能返回一个值,可以通过传入引用,获取更多信息.  

#### 数组传递
通常传入首地址指针和数组大小进行对数组的传递.

#### 数组引用传递
如: ```void f(int (&arr)[arrSize])```

#### initializer_list形参
如果函数的实参数量未知但类型相同,可使用 '*initializer_list*' 类型的形参.
如: ```void f(initializer_list<int> i)```  

### 返回值
函数可以返回一个值或void,但不能不要返回局部变量的指针或引用.
因为当函数执行完成后局部变量将被释放,此时指针或引用将指向有一个不存在的对象.  
当返回值为引用类型时,可当作左值使用.  

#### 返回值为数组的指针或引用
```todo```

#### 声明一个返回数组指针的函数
如果想定义一个返回数组指针的函数,则数组的维度必须紧跟函数名.但参数列表应先于数组的维度,所以函数声明格式如下:
```return_type (*func_name(parameter_list))[dimension]``` => ```int (*func(int i))[10]```.  
其中,```(*func(int i))```代表可以对函数调用的结果进行解引用,```(*func(int i))[10]```代表元素数量为10.

#### 尾置类型
在C++11中可以使用尾置类型(trailing return type)进行简化返回数组指针的函数声明.  
任何函数的声明定义都可以使用尾置类型,但对于返回类型复杂的函数更为有效.  
通过使用 '*auto*' 代替原先在函数名之前的返回类型,并在参数列表后添加 '->' 和真正的返回类型.
```cpp
// 使用尾置返回 int 的函数声明
auto add(int a, int b) -> int;
// 返回一个指向10个整数的数组的指针
auto func(int a) -> int (*)[10];
```  

#### 使用decltype声明返回类型
如果已知函数返回的指针指向某个数组,可以通过'*decltype*'关键词声明返回类型.
```cpp
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i){ return (i % 2) ? &odd : &even; }
```  

### 函数重载
如果同一作用域中几个函数的函数名相同,但返回类型和/或参数列表不同,则为重载(override)函数.
```cpp
int f(int a);
int f(int a, int b);
bool f(int a, int b);
void f(double a, double b, int c);
......
```

### 默认实参
对形参设置默认参数,如果为未传入参数,则使用默认值.
可对一或多个形参设置默认参数,但若一个参数有了默认参数,则其之后的参数也必须有默认参数.
```cpp
void f(int a = 1);
// 不允许
void f(int a = 1, int b);
```

### 内联函数
内联函数在编译过程中将被编译器插入调用处,而不是执行跳转调用.  
通常用于小型,关键的函数,可以减少函数调用的开销.
声明内联函数需要在函数声明前添加 '*inline*' 关键词.  
另外, '*constexpr*' 修饰的函数是隐式内联的,此关键词指示编译器函数可以被求值,且其结果在编译时是已知的,为使函数在编译时求值,其必须内联,这就意味着它必须在调用它的位置由编译器展开.  

### 函数指针  
与数据项相似,函数也有自身的地址.函数的地址时存储其机器代码的内存的开始地址.可以通过函数名获取函数的地址.
```cpp
// 函数原型如下:
int f(int);
// 声明一个函数指针
int (*pf)(int);
// 将函数地址赋给指针
pf = f;
// 调用函数指针
int a = (*pf)(5);
```